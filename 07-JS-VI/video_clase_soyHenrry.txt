ruta para ver el libro esta bueno y es avanzados
https://eloquentjavascript.net/index.html

funciones Cb

function decirHolaAlUsuario(usuario){
	return `Hola ${usuario}`;
}
function decirAdiosAlUsuario(usuario){
	return `Adi√≥s ${usuario}`;
}
function crearSaludo(usuario, cb){
	return cb(usuario);
}
crearSaludo('Harbey',decirHolaAlUsuario);
crearSaludo('Harbey',decirAdiosAlUsuario);

reutilizando funciones
//esta recibe algo y lo retorna con alguna funcion osea
crearSaludo(5,function(a){return a*2});

ARREGLOS CON FUNCIONES CALLBACKS


var alumnos=['mati','leo','tincho','emi','jimmy','franco'];
//sin callbacks
for (var i=0;i<alumnos.length;i++){
	console.log(alumnos[i]);
}
//con calbacks
alumnos.forEach(function(elemento, indice){
	console.log(elemento);
})
// este es desde documentacion mozilla mas simplificado aun

const array1 = ['a', 'b', 'c'];

array1.forEach(element => console.log(element));


// Arrow function
forEach((element) => { /* ... */ })
forEach((element, index) => { /* ... */ })
forEach((element, index, array) => { /* ... */ })

// Callback function
forEach(callbackFn)
forEach(callbackFn, thisArg)

// Inline callback function
forEach(function(element) { /* ... */ })
forEach(function(element, index) { /* ... */ })
forEach(function(element, index, array){ /* ... */ })
forEach(function(element, index, array) { /* ... */ }, thisArg)

///otro ejemplo
const ratings = [5, 4, 5];
let sum = 0;

const sumFunction = async (a, b) => a + b;

ratings.forEach(async (rating) => {
  sum = await sumFunction(sum, rating);
});

console.log(sum);
// Naively expected output: 14
// Actual output: 0

//otro ejemplo

//No operation for uninitialized values (sparse arrays)
const arraySparse = [1, 3,, 7];
let numCallbackRuns = 0;

arraySparse.forEach((element) => {
  console.log({ element });
  numCallbackRuns++;
});

console.log({ numCallbackRuns });

// 1
// 3
// 7
// numCallbackRuns: 3
// comment: as you can see the missing value between 3 and 7 didn't invoke callback function.


//otro ejemplo
//Converting a for loop to forEach
const items = ['item1', 'item2', 'item3'];
const copyItems = [];

// before
for (let i = 0; i < items.length; i++) {
  copyItems.push(items[i]);
}

// after
items.forEach((item) => {
  copyItems.push(item);
});

//otro mas

///Printing the contents of an array

const logArrayElements = (element, index, array) => {
  console.log('a[' + index + '] = ' + element);
};

// Notice that index 2 is skipped, since there is no item at
// that position in the array...
[2, 5,, 9].forEach(logArrayElements);
// logs:
// a[0] = 2
// a[1] = 5
// a[3] = 9


//Using thisArg

function Counter() {
  this.sum = 0
  this.count = 0
}

Counter.prototype.add = function(array) {
  array.forEach(function countEntry(entry) {
    this.sum += entry;
    ++this.count;
  }, this);
};

const obj = new Counter();
obj.add([2, 5, 9]);
console.log(obj.count); // 3
console.log(obj.sum); // 16


///otro con objetos
//An object copy function


const copy = (obj) => {
  const copy = Object.create(Object.getPrototypeOf(obj));
  const propNames = Object.getOwnPropertyNames(obj);
  propNames.forEach((name) => {
    const desc = Object.getOwnPropertyDescriptor(obj, name);
    Object.defineProperty(copy, name, desc);
  });
  return copy;
};

const obj1 = { a: 1, b: 2 };
const obj2 = copy(obj1); // obj2 looks like obj1 now

//Modifying the array during iteration

const words = ['one', 'two', 'three', 'four'];
words.forEach((word) => {
  console.log(word);
  if (word === 'two') {
    words.shift(); //'one' will delete from array
  }
}); // one // two // four

console.log(words); // ['two', 'three', 'four']


//Flatten an array

const flatten = (arr) => {
  const result = [];
  arr.forEach((i) => {
    if (Array.isArray(i)) {
      result.push(...flatten(i));
    } else {
      result.push(i);
    }
  });
  return result;
}

// Usage
const nested = [1, 2, 3, [4, 5, [6, 7], 8, 9]];
console.log(flatten(nested)); // [1, 2, 3, 4, 5, 6, 7, 8, 9]


//
	map
//

este crea un nuevo arreglo como resultado de la lamada

var numbers=[1,5,10,15];
var doubles=numbers.map(function(x){return x*2});


var alumnos=['mati','leo','tincho','emi','jimmy','franco'];

String.prototype.capitalize=function(){
	return this.charAt(0).toUpperCase() + this.slice(1);
}
//con callbacks
var nuevoAlumnos = alumnos.map(function(elemento, indice)
	return elemento.capitalize();
);

//sin callbacks

var nuevoArray=[];
for(var i=0;i<alumnos.length;i++){
	nuevoArray.push(alumnos[i].capitalize());
}


metodo reduce devuelve un unico valor



var nums=[1,2,3,4,5,6,7];
//sin callbacks
var suma=0;
for(var i=0;i<nums.length;i++){
	suma= suma + nums[i];
}
//con callbacks
var sumaReduce = nums.reduce(function(acomulador , elemento){
	return acomulador + elemento;
},0);


//ejemplo pagina de forEach

const autos=['Ford','Chevrolet','Toyota','Tesla'];
//podemos escribir el callback en los parentesis como una funcion anonima
autos.forEach(function(eleento, indice){
	console.log(elemento);	
});
//O podemos crear una instancia de una funcion para usarla como callback.
//Ademas, no necesitamos usar el argumanto de indice, si no lo necesitas, no duden en omitirlo
function mostrarNombres(elemento){
	console.log(elemento);
}
//llama la funcion forEach en paretesis
autos.forEach(mostrarNombres);


// ejemplo pagina reduce

const numeros=